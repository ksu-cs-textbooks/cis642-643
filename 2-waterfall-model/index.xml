




  
	
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
		
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The Waterfall Model :: K-State CIS 642/643 Textbook</title>
    <link>https://textbooks.cs.ksu.edu/cis642-643/2-waterfall-model/</link>
    <description>Go With the Flow</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 27 Jun 2024 15:29:22 -0500</lastBuildDate>
    <atom:link href="https://textbooks.cs.ksu.edu/cis642-643/2-waterfall-model/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Introduction</title>
      <link>https://textbooks.cs.ksu.edu/cis642-643/2-waterfall-model/01-introduction/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cis642-643/2-waterfall-model/01-introduction/</guid>
      <description>The waterfall model of software development breaks the process of creating software into discrete phases, as seen in this diagram:&#xA;The phases correspond to specific steps that must be carried out to create the software:&#xA;Requirements involves determining exactly what the software needs to do, as well as what platform(s) it needs to run on. Design involves designing the software system to meet those requirements - i.e. laying out a high-level architecture, often specifying this architecture with UML or similar approaches.</description>
    </item>
    <item>
      <title>Requirements Gathering</title>
      <link>https://textbooks.cs.ksu.edu/cis642-643/2-waterfall-model/02-requirements-gathering/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:05 -0500</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cis642-643/2-waterfall-model/02-requirements-gathering/</guid>
      <description>But what does it do?</description>
    </item>
    <item>
      <title>Waterfall Issues</title>
      <link>https://textbooks.cs.ksu.edu/cis642-643/2-waterfall-model/09-issues/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cis642-643/2-waterfall-model/09-issues/</guid>
      <description>You may be wondering, if this model of software engineering was so widely adopted, why did so many software projects continue to fail? Of course, some development houses never adopted a formal model, and rather continued in cowboy coding practices. But there were also many flaws in how the waterfall model was commonly adopted.&#xA;The ability to divide labor amongst the different phases was a boon from a business perspective, but it came with challenges.</description>
    </item>
    <item>
      <title>Design</title>
      <link>https://textbooks.cs.ksu.edu/cis642-643/2-waterfall-model/03-design/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:05 -0500</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cis642-643/2-waterfall-model/03-design/</guid>
      <description>Letâ€™s come up with a plan!</description>
    </item>
    <item>
      <title>Implementation</title>
      <link>https://textbooks.cs.ksu.edu/cis642-643/2-waterfall-model/04-implementation/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cis642-643/2-waterfall-model/04-implementation/</guid>
      <description>The implementation phase of the waterfall should be the most familiar to you, as it is the actual process of creating the proposed software system. This is, after all, the subject of most of your early coursework - the basics of programming, algorithm design, and considering time and memory complexity of your employed algorithms.&#xA;It is critical that the implementation adhere to the details provided by the design, as this ensures that a large body of programmers can work independently on the aspects of the system.</description>
    </item>
  </channel>
</rss>